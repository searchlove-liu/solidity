// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// AutomationCompatible.sol imports the functions from both ./AutomationBase.sol and
// ./interfaces/AutomationCompatibleInterface.sol
import {AutomationCompatibleInterface} from "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";

/**
 * @dev Example contract, use the Forwarder as needed for additional security.
 *
 * @notice important to implement {AutomationCompatibleInterface}
 */

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */
contract Counter is AutomationCompatibleInterface {
  /**
   * Public counter variable
   */
  uint256 public counter;

  /**
   * Use an interval in seconds and a timestamp to slow execution of Upkeep
   */
  uint256 public immutable interval;
  uint256 public lastTimeStamp;

// 时间间隔，秒
  constructor(
    uint256 updateInterval
  ) {
    interval = updateInterval;
    lastTimeStamp = block.timestamp;

    counter = 0;
  }

  function checkUpkeep(
    bytes calldata /* checkData */
  )
    external
    view
    override
    returns (
      bool upkeepNeeded,
      bytes memory /* performData */ 
    )
  {
    upkeepNeeded = ((block.timestamp - lastTimeStamp) > interval ) && counter <10 ;
    return (upkeepNeeded,"");
    // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
  }

  function performUpkeep(
    bytes calldata /* performData */
  ) external override {
    if ((block.timestamp - lastTimeStamp) > interval) {
      lastTimeStamp = block.timestamp;
      counter = counter + 1;
    }
    // We don't use the performData in this example. The performData is generated by the Automation Node's call to your
    // checkUpkeep function
  }
}

// demo2
// array [1000,1000,1000,1000...]
// 自动执行的条件是数组中元素发生改变
contract keepDemo2 is AutomationCompatibleInterface{
    uint256 constant ARRAY_VALUE =1000;
    uint256 constant ARRAY_LENGTH = 10;
    uint256[] public array; 
    constructor (){
        uint256[ARRAY_LENGTH] memory _array;
        for(uint256 i = 0;i < ARRAY_LENGTH;++i){
            _array[i]= ARRAY_VALUE;
        }
        array = _array;
    }

    //修改array数据
    // indexs是要修改的位置，amount是减去的值
    function withdraw(uint256[] calldata indexs,uint256 amount)external{
        uint256[] memory _array = array;
        uint256 length = indexs.length;
        for (uint256 i= 0;i <length ;i++){
            _array[indexs[i]] = ARRAY_VALUE - amount;
        }
        array = _array;
    } 

    // chainlink网络 检查是否执行的条件
    function checkUpkeep(
    bytes calldata /* checkData */
    ) external view returns (bool upkeepNeeded, bytes memory performData ){
        uint256[] memory _array = array;
        upkeepNeeded = false;
        for (uint256 i = 0;i < ARRAY_LENGTH;i++){
            if (_array[i] < ARRAY_VALUE){
                upkeepNeeded = true;
                break;
            }
        }
        return (upkeepNeeded,"");
    }

    function performUpkeep(bytes calldata /* performData */) external {
        uint256[] memory _array = array; 
        for(uint256 i = 0;i < ARRAY_LENGTH ;i++){
            if (_array[i] < ARRAY_VALUE){
                _array[i] = ARRAY_VALUE;
            }
        }
        array = _array;
    }
}

// demo2节省gas版本
// array [1000,1000,1000,1000...]
// 自动执行的条件是数组中元素发生改变
contract keepDemo2_v2 is AutomationCompatibleInterface{
    uint256 constant ARRAY_VALUE =1000;
    uint256 constant ARRAY_LENGTH = 10;
    uint256[] public array; 
    constructor (){
        uint256[ARRAY_LENGTH] memory _array;
        for(uint256 i = 0;i < ARRAY_LENGTH;++i){
            _array[i]= ARRAY_VALUE;
        }
        array = _array;
    }

    //修改array数据
    // indexs是要修改的位置，amount是减去的值
    function withdraw(uint256[] calldata indexs,uint256 amount)external{
        uint256[] memory _array = array;
        uint256 length = indexs.length;
        for (uint256 i= 0;i <length ;i++){
            _array[indexs[i]] = ARRAY_VALUE - amount;
        }
        array = _array;
    } 

    // chainlink网络 检查是否执行的条件
    function checkUpkeep(
    bytes calldata /* checkData */
    ) external view returns (bool upkeepNeeded, bytes memory performData ){
        uint256[] memory _array = array;
        upkeepNeeded = false;

        uint256 updateIndexsLength;
        for (uint256 i = 0;i < ARRAY_LENGTH;i++){
            if (_array[i] < ARRAY_VALUE){
                updateIndexsLength ++;
            }
        }

        // 定义需要修改的index
        uint256[] memory indexsToUpdate = new uint256[](updateIndexsLength);
        uint256 updateIndexCounter;
        for (uint256 i = 0;i < ARRAY_LENGTH; i++){
            if (_array[i] < ARRAY_VALUE){
                indexsToUpdate[updateIndexCounter]=i;
                updateIndexCounter++;
            }
        }
        
        if (updateIndexsLength  != 0){
          upkeepNeeded = true;
          performData = abi.encode(indexsToUpdate);
        }

        return (upkeepNeeded,performData);
    }

    function performUpkeep(bytes calldata performData ) external {
        uint256[] memory indexsToUpdate = abi.decode(performData, (uint256[]));
        uint256[] memory _array = array;
        uint256 updateIndexsLength = indexsToUpdate.length;
        for(uint256 i = 0;i < updateIndexsLength ;i++){
            _array[indexsToUpdate[i]] = ARRAY_VALUE;
        }
        array = _array;
    }
}
