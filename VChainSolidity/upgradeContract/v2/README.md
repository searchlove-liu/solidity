## keccak

0.8.2版本修复了0.8.1中存在的三个具体Bug，这些Bug都可能导致合约在特定情况下行为异常：

1. **Yul优化器错误**：优化器在对涉及`keccak256`哈希计算和常量的代码进行某些重组时，可能会生成**错误的字节码**。（在进行合约升级时，需要用到keccak256，计算数据存储位置，所以[openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol at v4.9.6 · OpenZeppelin/openzeppelin-contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/proxy/ERC1967/ERC1967Upgrade.sol)，代码中都使用0.8.2版本及以上）
2. **ABI编码器V2错误**：当调用一个接收**嵌套数组**（例如 `uint[][]`）作为参数的函数时，编码器可能产生**错误的Calldata数据**。
3. **内联汇编错误**：在内联汇编中使用新的 `mcopy` 指令时，如果源地址和目标地址重叠，可能会得到**错误的结果**。

最重要的是第一条：因为`keccak256`是`erc1967`中用于计算数据存储位置使用的，但它里面的结果是提前计算好了的，所以不需要再次使用`keccak256`来进行计算。
为了避免在0.8.1中使用`keccak256`出错，在使用`keccak256`时，需要提前使用高版本计算好值，设为常量，或在运行时通过keccak来进行计算。

map和可变数组同样使用了keccak256，但因为他们是在运行时执行的，而bug是在编译时执行的。所以不会影响。



## V2

V2基本使用的是openzeppelin的4.9.6版本合约库。部分库除外，例如初始化的库。
solidity编译版本使用0.8.1


#### 部署流程

1. 先部署V1合约
2. 再部署代理合约，部署代理合约时，传入V1合约地址和初始化函数数据，直接使用initialize()函数生成函数选择器就是第二个参数的数据。
   初始化函数数据是V1合约的初始化函数，赋值owner（必须proxy中调用，如果部署之后调用，黑客会提前调用v1的初始化函数，让合约拥有者变为黑客的账户），因为当前初始化函数是将部署着作为owner，所以不需要传参。
3. 代理合约中显示逻辑合约函数：将remixIED显示的文件变为V1合约，重新编译。在部署合约功能区域，在`At Address`区域内输入代理合约地址，就可以在代理合约中显示逻辑合约函数。
4. 如果想要升级合约。部署V2合约，最后通过proxy合约的`upgradeTo`方法，传入V2地址，发送就可以。